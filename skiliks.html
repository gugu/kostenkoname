<h1>Код</h1>

<ol>
<li>Разделение проекта на JS+API 
<ul>
<li>на разных серверах имеет смысл только для крупных enterprise проектах. В стартапе оно замедляет разработку.</li>
<li>стандартная поставка nginx не разрешает добавлять Access-Control-Allow-Origin для 500-х ошибок</li>
<li>front.skiliks.com не может нормально узнать, авторизован ли пользователь и показать ему веб-страницу в зависимости от авторизации
Рекомендации: на данном этапе уже поздно что-либо менять</li>
</ul></li>
<li>Самодельное кэширование в файлах. 
Не позволяет масштабировать кэш на несколько серверов, не чистится, не является атомарным. 
Рекомендация: заменить на Redis</li>
<li>Самодельная отправка почты.
<ol>
<li>@mail. Прятать ошибки при отправке почты неправильно. Пользователь получает странную ошибку, в логах ничего нет, об ошибке никто не узнает.</li>
<li>Заголовки вставляются конкатенацией без проверки, что небезопасно
Рекомедация: изпользовать пакет Mail из Pear (http://pear.php.net/package/Mail)</li>
</ol></li>
<li>Самодельное управление сессиями. Сессии хранятся в БД.
Запросы забивают кэши БД, высокие нагрузки будут нагружать базу. 
Рекомендация: использовать Redis и встроенную систему в yii управления сессиями.</li>
<li>Не используются миграции. Доработка приложения будет более сложной</li>
<li>Нет unit-тестов.</li>
<li><p>Нет отдельного метода выдачи данных в API. </p>

<pre><code>return $this-&gt;_sendResponse(200, CJSON::encode($result));
</code></pre>

<p>Если нужно будет как-то модифицировать сериализацию данных, заменить CJSON на что-либо другое или добавить параметры, то это будет очень сложно сделать</p></li>
<li>В БД время в unixtime. В базе данных есть встроенная работа со временем и датами, которая правильно работает с временными зонами, умеет правильно добавлять и удалять
интервалы. К тому же по ней можно понять дату и время, а по строке 1348337382 – нет
Рекомендация: заменить unixtime на datetime/timestamp</li>
<li><p>Нет проверок целостности.
Можно зарегистрироваться два раза с одной почтой (Два раза зарегистрироваться и кликнуть войти)
Рекомендация: использовать встроенные ограничения целостности MySQL. Для незарегистрированных пользователей использовать значение NULL вместо 0 для is_active</p></li>
<li><p>XSS уязвимости в тексте email и отображении пользовательских сообщений. К запуску нужно исправить</p></li>
<li>Сохранение паролей в md5 без соли небезопасно. По всему интернету гуляют радужные таблицы</li>
<li>Произвольный текст сообщения на сайте. Ничего страшного кроме репутации. Сайт, у которого каждый посетитель может написать слово "Жопа" на главной и отправить друзьям не 
будет выглядеть хорошо сделанным</li>
</ol>

<h1>Баги</h1>

<ol>
<li>Если я два раза зарегистрировался на один e-mail и активировал один из аккаунтов, то войти под ним невозможно (пользователь не активирован)</li>
</ol>
